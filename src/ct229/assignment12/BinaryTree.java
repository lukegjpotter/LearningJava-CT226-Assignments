package ct229.assignment12;/** * A class that implements the ADT binary tree. *  * @author Frank M. Carrano * @version 2.0 */import java.util.ArrayList;public class BinaryTree<T> implements BinaryTreeInterface<T>, java.io.Serializable{private static final long serialVersionUID = 1L;private BinaryNodeInterface<T> root;    public BinaryTree()  {    root = null;  } // end default constructor    public BinaryTree(T rootData)  {    root = new BinaryNode<T>(rootData);  } // end constructor    public BinaryTree(T rootData, BinaryTree<T> leftTree,                                 BinaryTree<T> rightTree)  {    privateSetTree(rootData, leftTree, rightTree);  } // end constructor    public void setTree(T rootData)  {    root = new BinaryNode<T>(rootData);  } // end setTree    public void setTree(T rootData, BinaryTreeInterface<T> leftTree,                                  BinaryTreeInterface<T> rightTree)  {    privateSetTree(rootData, (BinaryTree<T>)leftTree,                              (BinaryTree<T>)rightTree);  } // end setTree	// 26.08	private void privateSetTree(T rootData, BinaryTree<T> leftTree, 	                                        BinaryTree<T> rightTree)	{	  root = new BinaryNode<T>(rootData);	  	  if ((leftTree != null) && !leftTree.isEmpty())	    root.setLeftChild(leftTree.root);	    	  if ((rightTree != null) && !rightTree.isEmpty())	  {	    if (rightTree != leftTree)	      root.setRightChild(rightTree.root);	    else	      root.setRightChild(rightTree.root.copy());	  } // end if	  	  if ((leftTree != null) && (leftTree != this))	    leftTree.clear(); 	    	  if ((rightTree != null) && (rightTree != this))	    rightTree.clear();	} // end privateSetTree	@SuppressWarnings("unused")	private BinaryNode<T> copyNodes() // not essential	{		return (BinaryNode<T>)root.copy();	} // end copyNodes	// 26.09	public T getRootData()	{	  T rootData = null;	  	  if (root != null)	    rootData = root.getData();	    	  return rootData;	} // end getRootData	// 26.09	public boolean isEmpty()	{	  return root == null;	} // end isEmpty	// 26.09	public void clear()	{	  root = null;	} // end clear	// 26.09	protected void setRootData(T rootData)	{	  root.setData(rootData);	} // end setRootData	// 26.09	protected void setRootNode(BinaryNodeInterface<T> rootNode)	{	  root = rootNode;	} // end setRootNode	// 26.09	protected BinaryNodeInterface<T> getRootNode()	{	  return root;	} // end getRootNode	// 26.10	public int getHeight()	{	  return root.getHeight();	} // end getHeight	// 26.10	public int getNumberOfNodes()	{	  return root.getNumberOfNodes();	} // end getNumberOfNodes	// 26.12	public void inorderTraverse() 	{	  inorderTraverse(root);	} // end inorderTraverse	private void inorderTraverse(BinaryNodeInterface<T> node) 	{	  if (node != null)	  {	    inorderTraverse(node.getLeftChild());	    System.out.println(node.getData());	    inorderTraverse(node.getRightChild());	  } // end if	} // end inorderTraverse		public void breadthFirstTraverse()	{		//call method to traverse the tree using the breadth first algorithm		breadthFirstTraverse(root);	}		private void breadthFirstTraverse(BinaryNodeInterface<T> node)	{		//declare variables		ArrayList <BinaryNodeInterface<T>> arrlist = new ArrayList <BinaryNodeInterface<T>>();		ArrayList <BinaryNodeInterface<T>> childlist = new ArrayList <BinaryNodeInterface<T>>();		BinaryNodeInterface<T> temp;				//check id the root is empty		if(node != null)		{			//add root to the list			arrlist.add(node);			//check if left node exists			if(node.getLeftChild() != null)			{				//if it does then add it to the list				arrlist.add(node.getLeftChild());			}			//check if right node exists			if(node.getRightChild() != null)			{				//if it does then add it to the list				arrlist.add(node.getRightChild());			}		}				//check for and add children on the left		temp = node.getLeftChild();					if(temp != null)		{			//check if left node exists			if(temp.getLeftChild() != null)			{				//if it does then add it to the list				childlist.add(temp.getLeftChild());			}			//check if right node exists			if(temp.getRightChild() != null)			{				//if it does then add it to the list				childlist.add(temp.getRightChild());			}		}				//check for and add children on the right		temp = node.getRightChild();					if(temp != null)		{			//check if left node exists			if(temp.getLeftChild() != null)			{				//if it does then add it to the list				childlist.add(temp.getLeftChild());			}			//check if right node exists			if(temp.getRightChild() != null)			{				//if it does then add it to the list				childlist.add(temp.getRightChild());			}		}				//concatenate lists		arrlist.addAll(childlist);				//print the list out to the console		for(int i = 0; i < arrlist.size(); i++)		{			System.out.println(arrlist.get(i).getData());		}			}//end breadthFirstTraverse	} // end BinaryTree